import json
from difflib import SequenceMatcher
import sys
import re

used_cards = set()

def load_json_file(filename):
    """Load data from a JSON file."""
    with open(filename, 'r') as file:
        return json.load(file)

def get_mana_value(mana_cost):
    """Calculate the total mana value from a mana cost string, accounting for both numeric and color symbols."""
    if not mana_cost:
        # If mana_cost is an empty string, treat it as zero mana
        return 0

    mana_value = 0
    numeric_value = ''

    for char in mana_cost:
        if char.isdigit():
            numeric_value += char
        else:
            if numeric_value:
                mana_value += int(numeric_value)
                numeric_value = ''
            if char.isalpha():
                mana_value += 1

    if numeric_value:
        mana_value += int(numeric_value)

    return mana_value

def similar(a, b, fuzziness):
    """Measure the similarity of two strings with adjustable fuzziness."""
    return SequenceMatcher(None, a, b).ratio() >= fuzziness

def is_planeswalker(card_type):
    """Check if the card type includes 'Planeswalker'."""
    return 'Planeswalker' in card_type

def extract_unique_colors(mana_cost):
    """Extract unique colors from the mana cost, treating hybrid mana as either color, and ignoring '{X}'."""
    standard_colors = {'B', 'W', 'U', 'R', 'G'}
    colors = set()

    # Use a regular expression to find all occurrences of color symbols and hybrid symbols
    color_symbols = re.findall(r'\{([BWURGCX2/\)]+)\}', mana_cost)

    for symbol in color_symbols:
        if symbol in standard_colors:
            colors.add(symbol)
        elif '/' in symbol:  # Handle hybrid mana symbols like {G/U}
            for char in symbol:
                if char in standard_colors:
                    colors.add(char)
        elif symbol.isalpha() and symbol != 'X':
            colors.add('C')

    return colors

def is_land(card_type):
    """Check if the card type includes 'Land'."""
    return 'Land' in card_type

def find_highest_mana_card_of_color(lotr_cards, colors):
    """Find the card with the highest mana cost that matches the given colors."""
    best_card = None
    highest_mana_value = -1
    for card in lotr_cards:
        if all(color in card.get('manaCost', '') for color in colors):
            mana_value = get_mana_value(card['manaCost'])
            if mana_value > highest_mana_value:
                highest_mana_value = mana_value
                best_card = card
    return best_card

def find_strong_rare_creature_or_enchantment(lotr_cards, colors, card_type, mtg_mana_cost):
    """Find a strong creature or enchantment from the same colors, prioritizing mythic, then rare, then uncommon rarity."""
    best_card = None
    highest_power_toughness = -1
    rarities = ['mythic', 'rare', 'uncommon']

    # Determine if the MTG card is colorless
    is_colorless = colors == {'C'} or not colors

    for rarity in rarities:
        for card in lotr_cards:
            if card['type'].startswith(card_type) and card['rarity'] == rarity:
                lotr_mana_cost = card.get('manaCost', '')
                lotr_colors = extract_unique_colors(lotr_mana_cost)

                # Check color match; for colorless MTG cards, find colorless LOTR cards
                if (is_colorless and lotr_colors == {'C'}) or (not is_colorless and all(color in lotr_colors for color in colors)):
                    if 'Creature' in card_type:
                        power_toughness = sum(int(value) for value in [card.get('power', '0'), card.get('toughness', '0')] if value.isdigit())
                    else:
                        power_toughness = 0

                    if power_toughness > highest_power_toughness:
                        highest_power_toughness = power_toughness
                        best_card = card

        if best_card:
            break

    return best_card

def rarity_match(mtg_rarity, lotr_rarity):
    """Compare rarities, treating any non-standard rarity as 'rare'."""
    if mtg_rarity not in ["common", "uncommon", "rare", "mythic"]:
        mtg_rarity = "rare"
    return mtg_rarity == lotr_rarity

def extract_land_mana(text):
    """Extract and print the mana symbols generated by Land type cards from their text."""
    mana_symbols = []
    # Use regular expression to find and extract mana symbols like {W}, {B}, etc.
    mana_matches = re.findall(r'\{([BWURGC])\}', text)
    mana_symbols.extend(mana_matches)
    return mana_symbols

def find_land_mana(lotr_cards, mtg_card):
    mtg_land_mana = extract_land_mana(mtg_card.get('text', ''))
    matching_land = None

    basic_lands = ["Plains", "Forest", "Mountain", "Swamp", "Island"]

    # Check if the MTG card name is a basic land or its Snow-Covered version
    if mtg_card['name'] in basic_lands or mtg_card['name'].replace("Snow-Covered ", "") in basic_lands:
        # Directly use the basic land name for matching
        matching_land_name = mtg_card['name'].replace("Snow-Covered ", "")
        matching_land = next((card for card in lotr_cards if card['name'] == matching_land_name), None)
    else:
        for num_colors in range(len(mtg_land_mana), 0, -1):
            for card in lotr_cards:
                if is_land(card['type']):
                    lotr_land_text = card.get('text', '')
                    lotr_land_mana = extract_land_mana(lotr_land_text)
                    matching_colors = set(mtg_land_mana) & set(lotr_land_mana)
                    if len(matching_colors) == num_colors:
                        matching_land = card
                        break
            if matching_land:
                break

    if not matching_land:
        for color in mtg_land_mana:
            for card in lotr_cards:
                if is_land(card['type']):
                    lotr_land_text = card.get('text', '')
                    if color in extract_land_mana(lotr_land_text):
                        matching_land = card
                        break
            if matching_land:
                break

    if not matching_land:
        for card in lotr_cards:
            if is_land(card['type']) and 'C' in extract_land_mana(card.get('text', '')):
                matching_land = card
                break

    if matching_land is None:
        found_colors = ', '.join(mtg_land_mana)
        print(f"No matching land card found for name: {mtg_card['name']}")
        print(f"Colors in the MTG card text: {found_colors}")

    return matching_land

def similar_criteria_check(lotr_card, mtg_card, fuzziness):
    card_type = mtg_card['type']
    type_match = similar(card_type, lotr_card['type'], fuzziness)
    mtg_mana_cost = mtg_card.get('manaCost', '')
    lotr_mana_cost = lotr_card.get('manaCost', '')
    mana_match = is_mana_color_similar(mtg_mana_cost, lotr_mana_cost)
    mtg_mana_value = get_mana_value(mtg_mana_cost)
    lotr_mana_value = get_mana_value(lotr_mana_cost)
    power_toughness_match = similar(f"{mtg_card.get('power', '')}/{mtg_card.get('toughness', '')}",
                                    f"{lotr_card.get('power', '')}/{lotr_card.get('toughness', '')}", fuzziness)
    return type_match and rarity_match(mtg_card['rarity'], lotr_card['rarity']) and power_toughness_match and mana_match

def is_mana_color_similar(mtg_mana_cost, lotr_mana_cost):
    mtg_colors = extract_unique_colors(mtg_mana_cost)
    lotr_colors = extract_unique_colors(lotr_mana_cost)
    return mtg_colors == lotr_colors

def find_similar_cards(mtg_cards, lotr_cards, fuzziness):
    global used_cards
    converted_cards = []
    for mtg_card in mtg_cards:
        exact_match_found = False
        best_match = None
        for lotr_card in lotr_cards:
            if mtg_card['name'] == lotr_card['name']:
                exact_match_found = True
                best_match = lotr_card
                break

        if not exact_match_found:
            if is_planeswalker(mtg_card['type']):
                colors = extract_unique_colors(mtg_card.get('manaCost', ''))
                if not colors:  # If the planeswalker is colorless
                    colors.add('W')  # Treat it as white
                if 'C' in colors and len(colors) > 1:
                    colors.discard('C')
                best_match = find_strong_rare_creature_or_enchantment(lotr_cards, colors, "Creature", mtg_card.get('manaCost', ''))
                if not best_match and len(colors) > 1:
                    for color in colors:
                        best_match = find_strong_rare_creature_or_enchantment(lotr_cards, {color}, "Creature", mtg_card.get('manaCost', ''))
                        if best_match:
                            break

                if not best_match:
                    print(f"No match found for the planeswalker '{mtg_card['name']}' with any of the colors {colors}")
                    sys.exit(1)
            elif is_land(mtg_card['type']):
                matching_land = find_land_mana(lotr_cards, mtg_card)
                if matching_land:
                    converted_cards.append({
                        'mtg_card': mtg_card['name'],
                        'lotr_card': matching_land['name'],
                        'setCode': matching_land.get('setCode', '')
                    })
            else:
                card_type = mtg_card['type']

                mtg_colors = extract_unique_colors(mtg_card.get('manaCost', ''))

                match_found = False
                while not best_match and fuzziness > 0:
                    best_lotro_card_for_criteria = None
                    for lotr_card in lotr_cards:
                        lotr_colors = extract_unique_colors(lotr_card.get('manaCost', ''))

                        # Absolute check for color integrity
                        if not mtg_colors.issuperset(lotr_colors):
                            continue

                        type_match = similar(card_type, lotr_card['type'], fuzziness)
                        mtg_mana_value = get_mana_value(mtg_card.get('manaCost', ''))
                        lotr_mana_value = get_mana_value(lotr_card.get('manaCost', ''))
                        mana_match = is_mana_color_similar(mtg_card.get('manaCost', ''), lotr_card.get('manaCost', ''))
                        power_toughness_match = similar(f"{mtg_card.get('power', '')}/{mtg_card.get('toughness', '')}",
                                                        f"{lotr_card.get('power', '')}/{lotr_card.get('toughness', '')}", fuzziness)
                        if type_match and rarity_match(mtg_card['rarity'], lotr_card['rarity']) and power_toughness_match:
                            if mana_match:
                                best_match = lotr_card
                                match_found = True
                                break
                            else:
                                if best_lotro_card_for_criteria is None or lotr_mana_value > get_mana_value(
                                        best_lotro_card_for_criteria.get('manaCost', '')):
                                    best_lotro_card_for_criteria = lotr_card
                    if not best_match:
                        if best_lotro_card_for_criteria:
                            best_match = best_lotro_card_for_criteria
                            match_found = True
                        else:
                            fuzziness -= 0.1

                if not best_match:
                    criteria_values = {
                        'Card Type': card_type,
                        'Mana Cost': mtg_card.get('manaCost', ''),
                        'Rarity': mtg_card['rarity'],
                        'Power/Toughness': f"{mtg_card.get('power', '')}/{mtg_card.get('toughness', '')}"
                    }
                    failed_criteria = []
                    if not type_match:
                        failed_criteria.append("Card Type")
                    if not mana_match:
                        if mtg_mana_value > 10:
                            if mtg_mana_value > 15 and lotr_mana_value <= 15:
                                failed_criteria.append("Mana Cost (Very High Cost)")
                            else:
                                failed_criteria.append("Mana Cost (High Cost)")
                        else:
                            failed_criteria.append("Mana Cost")
                    if not rarity_match(mtg_card['rarity'], lotr_card['rarity']):
                        failed_criteria.append("Rarity")
                    if not power_toughness_match:
                        failed_criteria.append("Power/Toughness")

                    print(f"No match found for '{mtg_card['name']}' with the following criteria: {criteria_values}")
                    print(f"Failed criteria: {', '.join(failed_criteria)}")
                    sys.exit(1)

        if best_match:
            if not exact_match_found and best_match['name'] in used_cards:
                alternative_match = None
                for alt_card in lotr_cards:
                    if alt_card != best_match and similar_criteria_check(alt_card, mtg_card, fuzziness):
                        alternative_match = alt_card
                        break
                best_match = alternative_match if alternative_match else best_match
            
            used_cards.add(best_match['name'])
            converted_cards.append({
                'mtg_card': mtg_card['name'],
                'lotr_card': best_match['name'],
                'setCode': best_match.get('setCode', '')
            })

    return converted_cards

# Paths to the JSON files
mtg_json_file = 'database.json'
lotr_json_file = 'lotr.json'

# Load the data from JSON files
mtg_cards = load_json_file(mtg_json_file)
lotr_cards = load_json_file(lotr_json_file)

# Initial fuzziness level (can be adjusted)
initial_fuzziness = 0.8

# Find similar cards and write them to 'converted.json'
converted_cards = find_similar_cards(mtg_cards, lotr_cards, initial_fuzziness)
if converted_cards:
    with open('converted.json', 'w') as outfile:
        json.dump(converted_cards, outfile, indent=4)
    print("Conversion completed. Check 'converted.json' for results.")
